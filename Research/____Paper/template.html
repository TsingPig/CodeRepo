<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>Papers Visualizer</title>
<style>
body { font-family: "Segoe UI", system-ui, sans-serif; background:#f5f5f5; margin:20px; color:#222; }
h1 { color:#333; margin-bottom:16px; }
.paper { border:1px solid #ddd; padding:12px; margin:10px 0; background:white; border-radius:8px; box-shadow:0 2px 4px rgba(0,0,0,0.04); transition:background 0.2s ease, border-color 0.2s ease; }
.paper .actions { margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; }
input, textarea, select { width:100%; margin:4px 0; padding:8px; border-radius:6px; border:1px solid #ddd; }
button { margin:2px 0; padding:6px 12px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }
button:hover { background:#f0f0f0; }
.collapse { display:none; margin-top:8px; }
.note { background:#fff9db; border:1px solid #f2da75; border-radius:6px; padding:6px 8px; margin-top:6px; }
.note-header { display:flex; justify-content:space-between; align-items:center; font-weight:600; color:#9c6500; }
.note-header button { border:none; background:transparent; color:#b7791f; font-weight:600; }
.note-content { display:none; margin-top:6px; white-space:pre-wrap; font-size:0.95em; color:#5c3d00; }
.toolbar { display:flex; gap:8px; margin-bottom:16px; flex-wrap:wrap; }
.toolbar button { flex:none; }
.groups { display:flex; flex-direction:column; gap:12px; }
.group { border:1px solid #ccc; border-radius:10px; background:#fff; overflow:hidden; }
.group-header { display:flex; justify-content:space-between; align-items:center; padding:12px 16px; cursor:pointer; background:#f3f4f6; }
.group-title { font-weight:600; color:#111; }
.group-count { color:#555; font-size:0.9em; margin-left:8px; }
.group-collapse { display:none; padding:10px 16px 16px; }
.group.open .group-collapse { display:block; }
.group-header button { border:none; background:#e5e7eb; padding:4px 10px; border-radius:6px; }
.status { font-size:0.9em; color:#555; margin-bottom:12px; }
.status.error { color:#c53030; }
.status.success { color:#2f855a; }
.paper-header { display:flex; justify-content:space-between; gap:12px; align-items:flex-start; }
.paper-read { background:#f6fbf7; border-color:#c6f6d5; }
.paper-unread { background:#fff; border-color:#e2e8f0; }
.read-row { margin:6px 0 2px; display:flex; justify-content:flex-start; }
.read-flag { display:inline-flex; align-items:center; gap:4px; font-size:0.85em; color:#2f855a; white-space:nowrap; padding:4px 8px; border-radius:999px; background:rgba(47,133,90,0.12); }
.paper-unread .read-flag { color:#555; background:#f1f5f9; }
.read-flag input { width:auto; margin:0; }
.flat-mode { display:flex; flex-direction:column; gap:12px; }
</style>
</head>
<body>
<h1>ğŸ“š Papers Visualizer</h1>
<div class="toolbar">
    <input type="text" id="search" placeholder="æœç´¢æ ‡é¢˜/ä½œè€…/æ ‡ç­¾..." style="flex:1; min-width:220px;">
    <select id="venue-filter" style="flex:0 0 200px; min-width:160px;">
        <option value="all">å…¨éƒ¨ä¼šè®®/æœŸåˆŠ</option>
    </select>
    <select id="sort-by" style="flex:0 0 200px; min-width:160px;">
        <option value="default">é»˜è®¤æ’åºï¼ˆæ ‡ç­¾åˆ†ç»„ï¼‰</option>
        <option value="year-desc">å¹´ä»½ï¼ˆæ–°åˆ°æ—§ï¼‰</option>
        <option value="year-asc">å¹´ä»½ï¼ˆæ—§åˆ°æ–°ï¼‰</option>
        <option value="title-asc">æ ‡é¢˜ï¼ˆA-Zï¼‰</option>
        <option value="title-desc">æ ‡é¢˜ï¼ˆZ-Aï¼‰</option>
        <option value="venue-asc">ä¼šè®®åç§°ï¼ˆA-Zï¼‰</option>
        <option value="venue-desc">ä¼šè®®åç§°ï¼ˆZ-Aï¼‰</option>
    </select>
    <!-- æ–°å¢æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢æŒ‰é’® -->
    <button id="toggle-view-mode" style="background: #4f46e5; color: white; border-color: #4f46e5;">
        ğŸ“ åˆ‡æ¢åˆ°å¹³é“ºæ¨¡å¼
    </button>
    <button id="toggle-all-groups">ğŸ“ æŠ˜å æ‰€æœ‰</button>
    <button id="bind-file">ğŸ“‚ ç»‘å®š metadata.json</button>
    <button id="download-json">ğŸ’¾ å¯¼å‡º metadata.json</button>
    <button id="reload-data">ğŸ”„ é‡æ–°åŠ è½½</button>
</div>

<p id="status" class="status">åˆå§‹åŒ–ä¸­...</p>

<div id="papers" class="groups"></div>

<script>
const EMBEDDED_PAPERS = [];
let papers = [];
let metadataMap = {};
let metadataHandle = null;

const supportsFileSystemAccess = !!(window.showOpenFilePicker && window.isSecureContext);
const searchInput = document.getElementById('search');
const papersContainer = document.getElementById('papers');
const downloadBtn = document.getElementById('download-json');
const bindBtn = document.getElementById('bind-file');
const reloadBtn = document.getElementById('reload-data');
const statusEl = document.getElementById('status');
const venueFilter = document.getElementById('venue-filter');
const sortBySelect = document.getElementById('sort-by');
const toggleAllBtn = document.getElementById('toggle-all-groups');
const toggleViewModeBtn = document.getElementById('toggle-view-mode');  // æ–°å¢
let currentVenueFilter = 'all';
let currentSortBy = 'default';
let areAllGroupsExpanded = true;
let isFlatMode = false;  // æ–°å¢ï¼šå½“å‰æ˜¯å¦æ˜¯å¹³é“ºæ¨¡å¼

function escapeHtml(str = '') {
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

async function initApp() {
    bindBtn.addEventListener('click', handleBindFile);
    downloadBtn.addEventListener('click', () => persistMetadata({ auto: false }));
    reloadBtn.addEventListener('click', () => {
        if (metadataHandle) {
            loadFromHandle();
        } else {
            loadMetadataViaFetch({ fallbackToEmbedded: true });
        }
    });
    searchInput.addEventListener('input', e => render(getFilteredList(e.target.value)));
    venueFilter.addEventListener('change', e => {
        currentVenueFilter = e.target.value || 'all';
        render(getFilteredList(searchInput.value));
    });
    sortBySelect.addEventListener('change', e => {
        currentSortBy = e.target.value || 'default';
        render(getFilteredList(searchInput.value));
    });
    toggleAllBtn.addEventListener('click', toggleAllGroups);
    // æ–°å¢æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢äº‹ä»¶
    toggleViewModeBtn.addEventListener('click', toggleViewMode);

    await loadMetadataViaFetch({ fallbackToEmbedded: true });
}

function render(list) {
    papersContainer.innerHTML = '';
    
    if (!list.length) {
        papersContainer.innerHTML = `<div style="text-align:center; padding:40px; color:#666;">æš‚æ— æ•°æ®ï¼Œè¯·åŠ è½½ metadata.json</div>`;
        return;
    }
    
    if (isFlatMode) {
        // å¹³é“ºæ¨¡å¼ï¼šç›´æ¥å±•ç¤ºæ‰€æœ‰è®ºæ–‡
        renderFlatMode(list);
    } else {
        // åˆ†ç»„æ¨¡å¼ï¼šæŒ‰æ ‡ç­¾åˆ†ç»„å±•ç¤º
        renderGroupMode(list);
    }
}

function renderFlatMode(list) {
    papersContainer.className = 'flat-mode';
    
    const sortedItems = sortPapers(list, currentSortBy);
    sortedItems.forEach(p => {
        const paperCard = createPaperCard(p);
        // åœ¨å¹³é“ºæ¨¡å¼ä¸‹æ·»åŠ æ ‡ç­¾ä¿¡æ¯
        const tags = (p.tags || []).filter(Boolean);
        if (tags.length > 0) {
            const headerDiv = paperCard.querySelector('.paper-header > div');
            if (headerDiv) {
                const tagsHtml = tags.map(tag => 
                    `<span style="display:inline-block; background:#e5e7eb; color:#4b5563; padding:2px 8px; border-radius:12px; font-size:0.85em; margin-right:4px;">#${escapeHtml(tag)}</span>`
                ).join('');
                const tagsEl = document.createElement('div');
                tagsEl.style.marginTop = '4px';
                tagsEl.style.marginBottom = '4px';
                tagsEl.innerHTML = tagsHtml;
                headerDiv.appendChild(tagsEl);
            }
        }
        papersContainer.appendChild(paperCard);
    });
}

function renderGroupMode(list) {
    papersContainer.className = 'groups';
    const groups = groupByTag(list);
    
    Object.entries(groups).forEach(([tag, items]) => {
        const section = document.createElement('section');
        section.className = areAllGroupsExpanded ? 'group open' : 'group';
        section.innerHTML = `
            <div class="group-header" onclick="toggleGroup(this)">
                <div>
                    <span class="group-title"># ${escapeHtml(tag)}</span>
                    <span class="group-count">(${items.length})</span>
                </div>
                <button type="button">${areAllGroupsExpanded ? 'æŠ˜å ' : 'å±•å¼€'}</button>
            </div>
            <div class="group-collapse"></div>
        `;

        const collapse = section.querySelector('.group-collapse');
        const sortedItems = sortPapers(items, currentSortBy);
        sortedItems.forEach(p => collapse.appendChild(createPaperCard(p)));
        papersContainer.appendChild(section);
    });
}

// æ–°å¢ï¼šåˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼
function toggleViewMode() {
    isFlatMode = !isFlatMode;
    toggleViewModeBtn.textContent = isFlatMode ? 'ğŸ“ åˆ‡æ¢åˆ°åˆ†ç»„æ¨¡å¼' : 'ğŸ“ åˆ‡æ¢åˆ°å¹³é“ºæ¨¡å¼';
    toggleViewModeBtn.style.background = isFlatMode ? '#10b981' : '#4f46e5';
    toggleViewModeBtn.style.borderColor = isFlatMode ? '#10b981' : '#4f46e5';
    
    // åœ¨å¹³é“ºæ¨¡å¼ä¸‹éšè—æŠ˜å æ‰€æœ‰æŒ‰é’®ï¼Œåˆ†ç»„æ¨¡å¼ä¸‹æ˜¾ç¤º
    toggleAllBtn.style.display = isFlatMode ? 'none' : '';
    
    // é‡æ–°æ¸²æŸ“
    render(getFilteredList(searchInput.value));
}

function toggleAllGroups() {
    const groups = document.querySelectorAll('.group');
    if (groups.length === 0) return;
    
    areAllGroupsExpanded = !areAllGroupsExpanded;
    
    groups.forEach(group => {
        if (areAllGroupsExpanded) {
            group.classList.add('open');
            const button = group.querySelector('.group-header button');
            if (button) button.textContent = 'æŠ˜å ';
        } else {
            group.classList.remove('open');
            const button = group.querySelector('.group-header button');
            if (button) button.textContent = 'å±•å¼€';
        }
    });
    
    toggleAllBtn.textContent = areAllGroupsExpanded ? 'ğŸ“ æŠ˜å æ‰€æœ‰' : 'ğŸ“ å±•å¼€æ‰€æœ‰';
}

function groupByTag(list) {
    const grouped = {};
    const sortedList = sortPapers(list, currentSortBy);
    
    sortedList.forEach(p => {
        const tags = (p.tags && p.tags.length) ? p.tags : ['æœªåˆ†ç»„'];
        tags.forEach(tag => {
            const key = tag || 'æœªåˆ†ç»„';
            if (!grouped[key]) grouped[key] = [];
            grouped[key].push(p);
        });
    });
    
    return Object.fromEntries(Object.entries(grouped).sort((a,b)=>a[0].localeCompare(b[0], 'zh')));
}

function sortPapers(papersList, sortBy) {
    const sorted = [...papersList];
    
    switch(sortBy) {
        case 'year-desc':
            sorted.sort((a, b) => {
                const yearA = parseInt(a.year) || 0;
                const yearB = parseInt(b.year) || 0;
                return yearB - yearA;
            });
            break;
        case 'year-asc':
            sorted.sort((a, b) => {
                const yearA = parseInt(a.year) || 9999;
                const yearB = parseInt(b.year) || 9999;
                return yearA - yearB;
            });
            break;
        case 'title-asc':
            sorted.sort((a, b) => {
                const titleA = (a.title || '').toLowerCase().replace(/^(a|an|the)\s+/i, '');
                const titleB = (b.title || '').toLowerCase().replace(/^(a|an|the)\s+/i, '');
                return titleA.localeCompare(titleB, 'zh');
            });
            break;
        case 'title-desc':
            sorted.sort((a, b) => {
                const titleA = (a.title || '').toLowerCase().replace(/^(a|an|the)\s+/i, '');
                const titleB = (b.title || '').toLowerCase().replace(/^(a|an|the)\s+/i, '');
                return titleB.localeCompare(titleA, 'zh');
            });
            break;
        case 'venue-asc':
            sorted.sort((a, b) => {
                const venueA = (a.venue || '').toLowerCase();
                const venueB = (b.venue || '').toLowerCase();
                return venueA.localeCompare(venueB, 'zh') || (a.title || '').localeCompare(b.title || '', 'zh');
            });
            break;
        case 'venue-desc':
            sorted.sort((a, b) => {
                const venueA = (a.venue || '').toLowerCase();
                const venueB = (b.venue || '').toLowerCase();
                return venueB.localeCompare(venueA, 'zh') || (a.title || '').localeCompare(b.title || '', 'zh');
            });
            break;
    }
    return sorted;
}

function getFilteredList(q, venue = currentVenueFilter) {
    const query = normalize(q);
    return papers.filter(p => {
        const title = normalize(p.title);
        const authors = normalize(p.authors);
        const tagsText = normalize((p.tags || []).join(','));
        const venueText = normalize(p.venue || '');
        const matchesSearch = !query || title.includes(query) || authors.includes(query) || tagsText.includes(query) || venueText.includes(query);
        const matchesVenue = (venue === 'all') ? true : (normalize(venueText) === normalize(venue));
        return matchesSearch && matchesVenue;
    });
}

function createPaperCard(p) {
    const div = document.createElement('div');
    div.className = `paper ${p.read ? 'paper-read' : 'paper-unread'}`;
    const encodedLocal = p.pdf_local ? encodeURIComponent(p.pdf_local) : '';
    div.innerHTML = `
        <div class="paper-header">
            <div>
                <b>
                    <span style="color: #E53935;">
                        ${p.venue || p.year ? '[' : ''}${escapeHtml(p.venue || '')}${p.venue && p.year ? ' ' : ''}${p.year ? escapeHtml(p.year) : ''}${p.venue || p.year ? '] ' : ''}
                    </span>
                    <span style="color: black;">
                        ${escapeHtml(p.title)}
                    </span>
                </b><br>
                ä½œè€…: ${escapeHtml(p.authors)}<br>
            </div>
        </div>
        ${p.notes ? `
        <div class="note">
            <div class="note-header">
                <span>ğŸ“ å¤‡æ³¨</span>
                <button type="button" class="toggle-note" onclick="toggleNote(event, this)">å±•å¼€</button>
            </div>
            <div class="note-content">${escapeHtml(p.notes)}</div>
        </div>` : ''}

        <!-- æŒ‰é’®å’Œå·²è¯»åœ¨åŒä¸€è¡Œ -->
        <div class="actions" style="display: flex; align-items: center; gap: 4px; flex-wrap: nowrap;">
            ${p.pdf_local ? `<button type="button" onclick="openLocalSource('${encodedLocal}')" title="å°è¯•é€šè¿‡ file:// æ‰“å¼€åŸå§‹æ–‡ä»¶">æ‰“å¼€æºæ–‡ä»¶</button>` : ''}
            <button onclick="toggleEdit(this)">âœï¸ ç¼–è¾‘</button>
            <button type="button" onclick="openContainingFolder('${encodedLocal}')" title="æ‰“å¼€æ–‡ä»¶æ‰€åœ¨æ–‡ä»¶å¤¹å¹¶èšç„¦">ğŸ“‚ æ‰“å¼€æ‰€åœ¨ç›®å½•</button>

            <label class="read-flag" style="margin-left: auto; display: flex; align-items: center; gap: 4px;" title="æ ‡è®°æ˜¯å¦å·²è¯»">
                <input type="checkbox" ${p.read ? 'checked' : ''} onchange="handleReadToggle(event, '${p.file_key}')">
                ${p.read ? 'å·²è¯»' : 'æœªè¯»'}
            </label>
        </div>

        <div class="collapse">
            <input value="${escapeHtml(p.title)}" placeholder="æ ‡é¢˜" class="edit-title"><br>
            <input value="${escapeHtml(p.authors)}" placeholder="ä½œè€…" class="edit-authors"><br>
            <input value="${escapeHtml(p.year)}" placeholder="å¹´ä»½" class="edit-year"><br>
            <input value="${escapeHtml(p.venue || '')}" placeholder="ä¼šè®®/æœŸåˆŠ" class="edit-venue"><br>
            <input value="${escapeHtml((p.tags || []).join(', '))}" placeholder="æ ‡ç­¾,é€—å·åˆ†éš”" class="edit-tags"><br>
            <textarea class="edit-notes" placeholder="å¤‡æ³¨">${escapeHtml(p.notes)}</textarea><br>
            <textarea class="edit-bib" placeholder="BibTeX">${escapeHtml(p.bib)}</textarea><br>
            <button onclick="saveEdit(this, '${p.file_key}')">ğŸ’¾ ä¿å­˜å¹¶å¯¼å‡º metadata.json</button>
        </div>
    `;
    return div;
}

function openContainingFolder(encodedUri) {
    try {
        const path = decodeURIComponent(encodedUri || '');
        if (!path) return;

        const folderPath = path.replace(/\/[^\/]+$/, '');
        const opened = window.open(folderPath, '_blank');
        if (!opened) {
            showStatus('æµè§ˆå™¨é™åˆ¶æ— æ³•ç›´æ¥æ‰“å¼€æ–‡ä»¶å¤¹ï¼Œè·¯å¾„å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', true);
            if (navigator.clipboard?.writeText) {
                navigator.clipboard.writeText(path).catch(() => {});
            }
            alert('è¯·æ‰‹åŠ¨æ‰“å¼€æ–‡ä»¶å¤¹å¹¶å®šä½æ–‡ä»¶ï¼š\n' + path);
        } else {
            showStatus('å°è¯•æ‰“å¼€æ‰€åœ¨ç›®å½•ï¼Œå¦‚æœè¢«æ‹¦æˆªè¯·å…è®¸å¼¹çª—æˆ–å¤åˆ¶è·¯å¾„æ‰‹åŠ¨æ‰“å¼€', false);
        }
    } catch (err) {
        showStatus('æ— æ³•æ‰“å¼€æ–‡ä»¶å¤¹ï¼š' + err.message, true);
    }
}

function toggleEdit(btn) {
    const collapse = btn.parentNode.nextElementSibling;
    collapse.style.display = collapse.style.display === 'none' ? 'block' : 'none';
}

async function saveEdit(btn, key) {
    const parent = btn.parentNode;
    const p = papers.find(p=>p.file_key===key);
    if (!p) return;
    p.title = parent.querySelector('.edit-title').value;
    p.authors = parent.querySelector('.edit-authors').value;
    p.year = parent.querySelector('.edit-year').value;
    p.venue = parent.querySelector('.edit-venue').value.trim();
    p.tags = parent.querySelector('.edit-tags').value.split(',').map(t=>t.trim()).filter(Boolean);
    p.notes = parent.querySelector('.edit-notes').value;
    p.bib = parent.querySelector('.edit-bib').value;
    metadataMap[key] = { ...p };
    metadataMap[key].file_key = key;
    refreshVenueFilterOptions();
    render(getFilteredList(searchInput.value));
    await persistMetadata({ auto: true });
}

function toggleNote(event, btn) {
    event.stopPropagation();
    const content = btn.closest('.note').querySelector('.note-content');
    const isHidden = content.style.display === 'none' || content.style.display === '';
    content.style.display = isHidden ? 'block' : 'none';
    btn.textContent = isHidden ? 'æŠ˜å ' : 'å±•å¼€';
}

function openLocalSource(encodedUri) {
    try {
        const url = decodeURIComponent(encodedUri || '');
        if (!url) return;
        const opened = window.open(url, '_blank');
        if (!opened) {
            showStatus('æµè§ˆå™¨é˜»æ­¢ç›´æ¥æ‰“å¼€æœ¬åœ°æ–‡ä»¶ï¼Œå·²å¤åˆ¶è·¯å¾„ï¼Œè¯·æ‰‹åŠ¨ç²˜è´´åˆ°èµ„æºç®¡ç†å™¨æˆ– PDF ç¼–è¾‘å™¨ä¸­ã€‚', true);
            if (navigator.clipboard?.writeText) {
                navigator.clipboard.writeText(url).catch(() => {});
            }
            alert('å¦‚æœæµè§ˆå™¨é˜»æ­¢ file:// é“¾æ¥ï¼Œè¯·æ‰‹åŠ¨åœ¨èµ„æºç®¡ç†å™¨ä¸­æ‰“å¼€ï¼š\n' + url);
        } else {
            showStatus('å·²å°è¯•é€šè¿‡ file:// æ‰“å¼€åŸå§‹æ–‡ä»¶ï¼Œå¦‚è¢«æ‹¦æˆªè¯·å…è®¸æ­¤æ“ä½œæˆ–å¤åˆ¶è·¯å¾„æ‰‹åŠ¨æ‰“å¼€ã€‚', false);
        }
    } catch (err) {
        showStatus('æ— æ³•æ‰“å¼€æœ¬åœ°æ–‡ä»¶ï¼š' + err.message, true);
    }
}

function toggleGroup(header) {
    const group = header.closest('.group');
    const button = header.querySelector('button');
    const isOpen = group.classList.toggle('open');
    button.textContent = isOpen ? 'æŠ˜å ' : 'å±•å¼€';
}

function normalize(str = '') {
    return str.toLowerCase().replace(/[\s_\-]+/g, '');
}

function arrayToMetadataMap(list) {
    const map = {};
    list.forEach((item, index) => {
        const rawKey = item.file_key || item.pdf || `paper_${index}`;
        const key = String(rawKey).toLowerCase();
        map[key] = { ...item, file_key: key };
    });
    return map;
}

function applyMetadataMap(map) {
    metadataMap = map || {};
    papers = Object.entries(metadataMap).map(([key, value]) => ({
        file_key: key,
        ...value,
        tags: (value.tags || []).filter(Boolean),
        venue: (value.venue || '').trim(),
        read: !!value.read
    }));
    refreshVenueFilterOptions();
    render(getFilteredList(searchInput.value));
}

async function handleReadToggle(event, key) {
    event.stopPropagation();
    event.preventDefault();
    const checked = event.target.checked;
    const p = papers.find(item => item.file_key === key);
    if (!p) return;
    p.read = checked;
    metadataMap[key] = { ...(metadataMap[key] || {}), ...p, read: checked };
    metadataMap[key].file_key = key;
    await persistMetadata({ auto: true });
    render(getFilteredList(searchInput.value));
}

function refreshVenueFilterOptions() {
    if (!venueFilter) return;
    const previous = currentVenueFilter;
    const venues = Array.from(new Set(
        papers
            .map(p => (p.venue || '').trim())
            .filter(Boolean)
    )).sort((a,b)=>a.localeCompare(b, 'zh'));
    const options = ['<option value="all">å…¨éƒ¨ä¼šè®®/æœŸåˆŠ</option>'];
    venues.forEach(v => {
        options.push(`<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`);
    });
    venueFilter.innerHTML = options.join('');
    if (previous === 'all') {
        venueFilter.value = 'all';
        currentVenueFilter = 'all';
        return;
    }
    const exists = venues.some(v => v === previous);
    currentVenueFilter = exists ? previous : 'all';
    venueFilter.value = currentVenueFilter;
}

async function loadMetadataViaFetch({ fallbackToEmbedded = false } = {}) {
    try {
        const response = await fetch(`metadata.json?ts=${Date.now()}`, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        applyMetadataMap(data);
        showStatus('å·²ä»åŒç›®å½• metadata.json åŠ è½½æ•°æ®', false);
    } catch (error) {
        if (fallbackToEmbedded && Array.isArray(EMBEDDED_PAPERS) && EMBEDDED_PAPERS.length) {
            applyMetadataMap(arrayToMetadataMap(EMBEDDED_PAPERS));
            showStatus('æ— æ³•è¯»å– metadata.jsonï¼Œå·²å›é€€è‡³å†…ç½®æ•°æ®ï¼›å»ºè®®ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨æˆ–ç»‘å®šæ–‡ä»¶ä»¥ä¿æŒåŒæ­¥', true);
        } else {
            showStatus('æ— æ³•ç›´æ¥è¯»å– metadata.jsonï¼Œè¯·ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨æˆ–"ç»‘å®š"æŒ‰é’®æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶', true);
            render([]);
        }
    }
}

async function handleBindFile() {
    if (!supportsFileSystemAccess) {
        alert('å½“å‰ç¯å¢ƒä¸æ”¯æŒç›´æ¥å†™å…¥æ–‡ä»¶ï¼Œè¯·é€šè¿‡æœ¬åœ°æœåŠ¡å™¨ (å¦‚ python -m http.server) è®¿é—®æˆ–ä½¿ç”¨ä¸‹è½½å¯¼å‡ºæ–¹å¼ã€‚');
        return;
    }
    try {
        [metadataHandle] = await window.showOpenFilePicker({
            types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
        });
        await loadFromHandle();
    } catch (err) {
        if (err?.name !== 'AbortError') {
            showStatus('ç»‘å®šæ–‡ä»¶å¤±è´¥ï¼š' + err.message, true);
        }
    }
}

async function loadFromHandle() {
    if (!metadataHandle) return;
    const file = await metadataHandle.getFile();
    const text = await file.text();
    const data = JSON.parse(text || '{}');
    applyMetadataMap(data);
    showStatus(`å·²ç»‘å®š ${file.name}ï¼Œåç»­ä¿å­˜å°†è‡ªåŠ¨è¦†ç›–`, false);
}

async function persistMetadata({ auto }) {
    const payload = JSON.stringify(metadataMap, null, 2);
    if (supportsFileSystemAccess && !metadataHandle) {
        metadataHandle = await promptForSaveHandle(auto);
    }

    if (metadataHandle && supportsFileSystemAccess) {
        const writable = await metadataHandle.createWritable();
        await writable.write(payload);
        await writable.close();
        showStatus('metadata.json å·²è‡ªåŠ¨è¦†ç›–ä¿å­˜', false);
    } else {
        triggerDownloadFallback(payload, auto);
    }
}

function showStatus(message, isError) {
    statusEl.textContent = message;
    statusEl.classList.toggle('error', !!isError);
    statusEl.classList.toggle('success', !isError);
}

function triggerDownloadFallback(payload, auto) {
    const blob = new Blob([payload], { type: 'application/json' });
    const filename = auto ? `metadata_auto_${Date.now()}.json` : 'metadata.json';
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
    showStatus('æµè§ˆå™¨é™åˆ¶ï¼Œå·²è§¦å‘ metadata.json ä¸‹è½½ï¼Œè¯·æ‰‹åŠ¨æ›¿æ¢æˆ–ä½¿ç”¨"ç»‘å®š/é€‰æ‹©ä¿å­˜æ–‡ä»¶"', true);
}

async function promptForSaveHandle(auto) {
    if (!supportsFileSystemAccess) return null;
    try {
        const handle = await window.showSaveFilePicker({
            suggestedName: 'metadata.json',
            types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
        });
        showStatus(`å·²é€‰æ‹© ${handle.name || 'metadata.json'}ï¼Œåç»­ä¿å­˜å°†è‡ªåŠ¨è¦†ç›–`, false);
        return handle;
    } catch (err) {
        if (err?.name !== 'AbortError') {
            showStatus('æœªè·å¾—æ–‡ä»¶å†™å…¥æƒé™ï¼Œå·²é€€å›ä¸‹è½½æ–¹å¼', true);
        } else if (!auto) {
            showStatus('å·²å–æ¶ˆé€‰æ‹©æ–‡ä»¶ï¼Œä¿å­˜ä¼šæ”¹ä¸ºä¸‹è½½', true);
        }
        return null;
    }
}

// åˆå§‹åŒ–
initApp();
</script>
</body>
</html>