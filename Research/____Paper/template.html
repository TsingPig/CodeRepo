<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>è®ºæ–‡ç®¡ç†ç³»ç»Ÿ</title>
<style>
body { font-family: "Segoe UI", system-ui, sans-serif; background:#f5f5f5; margin:20px; color:#222; }
h1 { color:#333; margin-bottom:16px; }
.paper { border:1px solid #ddd; padding:12px; margin:10px 0; background:white; border-radius:8px; box-shadow:0 2px 4px rgba(0,0,0,0.04); transition:background 0.2s ease, border-color 0.2s ease; }
.paper .actions { margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; }
input, textarea, select { width:100%; margin:4px 0; padding:8px; border-radius:6px; border:1px solid #ddd; }
button { margin:2px 0; padding:6px 12px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }
button:hover { background:#f0f0f0; }
.collapse { display:none; margin-top:8px; }
.note { background:#fff9db; border:1px solid #f2da75; border-radius:6px; padding:6px 8px; margin-top:6px; }
.note-header { display:flex; justify-content:space-between; align-items:center; font-weight:600; color:#9c6500; }
.note-header button { border:none; background:transparent; color:#b7791f; font-weight:600; }
.note-content { display:none; margin-top:6px; white-space:pre-wrap; font-size:0.95em; color:#5c3d00; }
.toolbar { display:flex; gap:8px; margin-bottom:16px; flex-wrap:wrap; }
.toolbar button { flex:none; }
.groups { display:flex; flex-direction:column; gap:12px; }
.group { border:1px solid #ccc; border-radius:10px; background:#fff; overflow:hidden; }
.group-header { display:flex; justify-content:space-between; align-items:center; padding:12px 16px; cursor:pointer; background:#f3f4f6; }
.group-title { font-weight:600; color:#111; }
.group-count { color:#555; font-size:0.9em; margin-left:8px; }
.group-collapse { display:none; padding:10px 16px 16px; }
.group.open .group-collapse { display:block; }
.group-header button { border:none; background:#e5e7eb; padding:4px 10px; border-radius:6px; }
.status { font-size:0.9em; color:#555; margin-bottom:12px; }
.status.error { color:#c53030; }
.status.success { color:#2f855a; }
.paper-header { display:flex; justify-content:space-between; gap:12px; align-items:flex-start; }
.paper-read { background:#f6fbf7; border-color:#c6f6d5; }
.paper-unread { background:#fff; border-color:#e2e8f0; }
.read-row { margin:6px 0 2px; display:flex; justify-content:flex-start; }
.read-flag { display:inline-flex; align-items:center; gap:4px; font-size:0.85em; color:#2f855a; white-space:nowrap; padding:4px 8px; border-radius:999px; background:rgba(47,133,90,0.12); }
.paper-unread .read-flag { color:#555; background:#f1f5f9; }
.read-flag input { width:auto; margin:0; }
</style>
</head>
<body>
<h1>ğŸ“š è®ºæ–‡ç®¡ç†ç³»ç»Ÿ</h1>
<div class="toolbar">
    <input type="text" id="search" placeholder="æœç´¢æ ‡é¢˜/ä½œè€…/æ ‡ç­¾..." style="flex:1; min-width:220px;">
    <select id="venue-filter" style="flex:0 0 200px; min-width:160px;">
        <option value="all">å…¨éƒ¨ä¼šè®®/æœŸåˆŠ</option>
    </select>
    <button id="bind-file">ğŸ“‚ ç»‘å®š metadata.json</button>
    <button id="download-json">ğŸ’¾ å¯¼å‡º metadata.json</button>
    <button id="reload-data">ğŸ”„ é‡æ–°åŠ è½½</button>
</div>

<p id="status" class="status">åˆå§‹åŒ–ä¸­...</p>

<div id="papers" class="groups"></div>

<script>
const EMBEDDED_PAPERS = [];
let papers = [];
let metadataMap = {};
let metadataHandle = null;

const supportsFileSystemAccess = !!(window.showOpenFilePicker && window.isSecureContext);
const searchInput = document.getElementById('search');
const papersContainer = document.getElementById('papers');
const downloadBtn = document.getElementById('download-json');
const bindBtn = document.getElementById('bind-file');
const reloadBtn = document.getElementById('reload-data');
const statusEl = document.getElementById('status');
const venueFilter = document.getElementById('venue-filter');
let currentVenueFilter = 'all';

function escapeHtml(str = '') {
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

async function initApp() {
    bindBtn.addEventListener('click', handleBindFile);
    downloadBtn.addEventListener('click', () => persistMetadata({ auto: false }));
    reloadBtn.addEventListener('click', () => {
        if (metadataHandle) {
            loadFromHandle();
        } else {
            loadMetadataViaFetch({ fallbackToEmbedded: true });
        }
    });
    searchInput.addEventListener('input', e => render(getFilteredList(e.target.value)));
    venueFilter.addEventListener('change', e => {
        currentVenueFilter = e.target.value || 'all';
        render(getFilteredList(searchInput.value));
    });

    await loadMetadataViaFetch({ fallbackToEmbedded: true });
}

function render(list) {
    papersContainer.innerHTML = '';
    const groups = groupByTag(list);
    if (!Object.keys(groups).length) {
        papersContainer.innerHTML = `<div style="text-align:center; padding:40px; color:#666;">æš‚æ— æ•°æ®ï¼Œè¯·åŠ è½½ metadata.json</div>`;
        return;
    }
    Object.entries(groups).forEach(([tag, items]) => {
        const section = document.createElement('section');
        section.className = 'group open';
        section.innerHTML = `
            <div class="group-header" onclick="toggleGroup(this)">
                <div>
                    <span class="group-title"># ${escapeHtml(tag)}</span>
                    <span class="group-count">(${items.length})</span>
                </div>
                <button type="button">æŠ˜å </button>
            </div>
            <div class="group-collapse"></div>
        `;

        const collapse = section.querySelector('.group-collapse');
        items.forEach(p => collapse.appendChild(createPaperCard(p)));
        papersContainer.appendChild(section);
    });
}

function groupByTag(list) {
    const grouped = {};
    list.forEach(p => {
        const tags = (p.tags && p.tags.length) ? p.tags : ['æœªåˆ†ç»„'];
        tags.forEach(tag => {
            const key = tag || 'æœªåˆ†ç»„';
            if (!grouped[key]) grouped[key] = [];
            grouped[key].push(p);
        });
    });
    return Object.fromEntries(Object.entries(grouped).sort((a,b)=>a[0].localeCompare(b[0], 'zh')));
}

function createPaperCard(p) {
    const div = document.createElement('div');
    div.className = `paper ${p.read ? 'paper-read' : 'paper-unread'}`;
    const encodedLocal = p.pdf_local ? encodeURIComponent(p.pdf_local) : '';
    div.innerHTML = `
        <div class="paper-header">
            <div>
                <b>${escapeHtml(p.title)}</b> (${escapeHtml(p.year)})<br>
                ä½œè€…: ${escapeHtml(p.authors)}<br>
                ä¼šè®®/æœŸåˆŠ: ${escapeHtml(p.venue || 'æœªå¡«å†™')}<br>
                æ ‡ç­¾: ${escapeHtml((p.tags || []).join(', '))}<br>
            </div>
        </div>
        <div class="read-row">
            <label class="read-flag" title="æ ‡è®°æ˜¯å¦å·²è¯»">
                <input type="checkbox" ${p.read ? 'checked' : ''} onchange="handleReadToggle(event, '${p.file_key}')">
                ${p.read ? 'å·²è¯»' : 'æœªè¯»'}
            </label>
        </div>
        ${p.notes ? `
        <div class="note">
            <div class="note-header">
                <span>ğŸ“ å¤‡æ³¨</span>
                <button type="button" class="toggle-note" onclick="toggleNote(event, this)">å±•å¼€</button>
            </div>
            <div class="note-content">${escapeHtml(p.notes)}</div>
        </div>` : ''}
        <div class="actions">
            <a href="${escapeHtml(p.pdf)}" target="_blank" rel="noopener">ğŸŒ æµè§ˆå™¨æ‰“å¼€</a>
            ${p.pdf_local ? `<button type="button" onclick="openLocalSource('${encodedLocal}')" title="å°è¯•é€šè¿‡ file:// æ‰“å¼€åŸå§‹æ–‡ä»¶">ï¿½ï¸ æ‰“å¼€æºæ–‡ä»¶</button>` : ''}
            <button onclick="toggleEdit(this)">âœï¸ ç¼–è¾‘</button>
        </div>
        <div class="collapse">
            <input value="${escapeHtml(p.title)}" placeholder="æ ‡é¢˜" class="edit-title"><br>
            <input value="${escapeHtml(p.authors)}" placeholder="ä½œè€…" class="edit-authors"><br>
            <input value="${escapeHtml(p.year)}" placeholder="å¹´ä»½" class="edit-year"><br>
            <input value="${escapeHtml(p.venue || '')}" placeholder="ä¼šè®®/æœŸåˆŠ" class="edit-venue"><br>
            <input value="${escapeHtml((p.tags || []).join(', '))}" placeholder="æ ‡ç­¾,é€—å·åˆ†éš”" class="edit-tags"><br>
            <textarea class="edit-notes" placeholder="å¤‡æ³¨">${escapeHtml(p.notes)}</textarea><br>
            <textarea class="edit-bib" placeholder="BibTeX">${escapeHtml(p.bib)}</textarea><br>
            <button onclick="saveEdit(this, '${p.file_key}')">ğŸ’¾ ä¿å­˜å¹¶å¯¼å‡º metadata.json</button>
        </div>
    `;
    return div;
}

function toggleEdit(btn) {
    const collapse = btn.parentNode.nextElementSibling;
    collapse.style.display = collapse.style.display === 'none' ? 'block' : 'none';
}

async function saveEdit(btn, key) {
    const parent = btn.parentNode;
    const p = papers.find(p=>p.file_key===key);
    if (!p) return;
    p.title = parent.querySelector('.edit-title').value;
    p.authors = parent.querySelector('.edit-authors').value;
    p.year = parent.querySelector('.edit-year').value;
    p.venue = parent.querySelector('.edit-venue').value.trim();
    p.tags = parent.querySelector('.edit-tags').value.split(',').map(t=>t.trim()).filter(Boolean);
    p.notes = parent.querySelector('.edit-notes').value;
    p.bib = parent.querySelector('.edit-bib').value;
    metadataMap[key] = { ...p };
    metadataMap[key].file_key = key;
    refreshVenueFilterOptions();
    render(getFilteredList(searchInput.value));
    await persistMetadata({ auto: true });
}

function toggleNote(event, btn) {
    event.stopPropagation();
    const content = btn.closest('.note').querySelector('.note-content');
    const isHidden = content.style.display === 'none' || content.style.display === '';
    content.style.display = isHidden ? 'block' : 'none';
    btn.textContent = isHidden ? 'æŠ˜å ' : 'å±•å¼€';
}

function openLocalSource(encodedUri) {
    try {
        const url = decodeURIComponent(encodedUri || '');
        if (!url) return;
        const opened = window.open(url, '_blank');
        if (!opened) {
            showStatus('æµè§ˆå™¨é˜»æ­¢ç›´æ¥æ‰“å¼€æœ¬åœ°æ–‡ä»¶ï¼Œå·²å¤åˆ¶è·¯å¾„ï¼Œè¯·æ‰‹åŠ¨ç²˜è´´åˆ°èµ„æºç®¡ç†å™¨æˆ– PDF ç¼–è¾‘å™¨ä¸­ã€‚', true);
            if (navigator.clipboard?.writeText) {
                navigator.clipboard.writeText(url).catch(() => {});
            }
            alert('å¦‚æœæµè§ˆå™¨é˜»æ­¢ file:// é“¾æ¥ï¼Œè¯·æ‰‹åŠ¨åœ¨èµ„æºç®¡ç†å™¨ä¸­æ‰“å¼€ï¼š\n' + url);
        } else {
            showStatus('å·²å°è¯•é€šè¿‡ file:// æ‰“å¼€åŸå§‹æ–‡ä»¶ï¼Œå¦‚è¢«æ‹¦æˆªè¯·å…è®¸æ­¤æ“ä½œæˆ–å¤åˆ¶è·¯å¾„æ‰‹åŠ¨æ‰“å¼€ã€‚', false);
        }
    } catch (err) {
        showStatus('æ— æ³•æ‰“å¼€æœ¬åœ°æ–‡ä»¶ï¼š' + err.message, true);
    }
}

function toggleGroup(header) {
    const group = header.closest('.group');
    const button = header.querySelector('button');
    const isOpen = group.classList.toggle('open');
    button.textContent = isOpen ? 'æŠ˜å ' : 'å±•å¼€';
}

function getFilteredList(q, venue = currentVenueFilter) {
    const query = (q || '').toLowerCase();
    return papers.filter(p => {
        const tagsText = (p.tags || []).join(',');
        const venueText = (p.venue || '');
        const matchesSearch = !query ||
            p.title.toLowerCase().includes(query) ||
            p.authors.toLowerCase().includes(query) ||
            tagsText.toLowerCase().includes(query) ||
            venueText.toLowerCase().includes(query);
        const matchesVenue = (venue === 'all') ? true : (venueText.trim() === venue);
        return matchesSearch && matchesVenue;
    });
}

function arrayToMetadataMap(list) {
    const map = {};
    list.forEach((item, index) => {
        const rawKey = item.file_key || item.pdf || `paper_${index}`;
        const key = String(rawKey).toLowerCase();
        map[key] = { ...item, file_key: key };
    });
    return map;
}

function applyMetadataMap(map) {
    metadataMap = map || {};
    papers = Object.entries(metadataMap).map(([key, value]) => ({
        file_key: key,
        ...value,
        tags: (value.tags || []).filter(Boolean),
        venue: (value.venue || '').trim(),
        read: !!value.read
    }));
    refreshVenueFilterOptions();
    render(getFilteredList(searchInput.value));
}

async function handleReadToggle(event, key) {
    event.stopPropagation();
    const checked = event.target.checked;
    const p = papers.find(item => item.file_key === key);
    if (!p) return;
    p.read = checked;
    metadataMap[key] = { ...(metadataMap[key] || {}), ...p, read: checked };
    metadataMap[key].file_key = key;
    await persistMetadata({ auto: true });
    render(getFilteredList(searchInput.value));
}

function refreshVenueFilterOptions() {
    if (!venueFilter) return;
    const previous = currentVenueFilter;
    const venues = Array.from(new Set(
        papers
            .map(p => (p.venue || '').trim())
            .filter(Boolean)
    )).sort((a,b)=>a.localeCompare(b, 'zh'));
    const options = ['<option value="all">å…¨éƒ¨ä¼šè®®/æœŸåˆŠ</option>'];
    venues.forEach(v => {
        options.push(`<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`);
    });
    venueFilter.innerHTML = options.join('');
    if (previous === 'all') {
        venueFilter.value = 'all';
        currentVenueFilter = 'all';
        return;
    }
    const exists = venues.some(v => v === previous);
    currentVenueFilter = exists ? previous : 'all';
    venueFilter.value = currentVenueFilter;
}

async function loadMetadataViaFetch({ fallbackToEmbedded = false } = {}) {
    try {
        const response = await fetch(`metadata.json?ts=${Date.now()}`, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        applyMetadataMap(data);
        showStatus('å·²ä»åŒç›®å½• metadata.json åŠ è½½æ•°æ®', false);
    } catch (error) {
        if (fallbackToEmbedded && Array.isArray(EMBEDDED_PAPERS) && EMBEDDED_PAPERS.length) {
            applyMetadataMap(arrayToMetadataMap(EMBEDDED_PAPERS));
            showStatus('æ— æ³•è¯»å– metadata.jsonï¼Œå·²å›é€€è‡³å†…ç½®æ•°æ®ï¼›å»ºè®®ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨æˆ–ç»‘å®šæ–‡ä»¶ä»¥ä¿æŒåŒæ­¥', true);
        } else {
            showStatus('æ— æ³•ç›´æ¥è¯»å– metadata.jsonï¼Œè¯·ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨æˆ–â€œç»‘å®šâ€æŒ‰é’®æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶', true);
            render([]);
        }
    }
}

async function handleBindFile() {
    if (!supportsFileSystemAccess) {
        alert('å½“å‰ç¯å¢ƒä¸æ”¯æŒç›´æ¥å†™å…¥æ–‡ä»¶ï¼Œè¯·é€šè¿‡æœ¬åœ°æœåŠ¡å™¨ (å¦‚ python -m http.server) è®¿é—®æˆ–ä½¿ç”¨ä¸‹è½½å¯¼å‡ºæ–¹å¼ã€‚');
        return;
    }
    try {
        [metadataHandle] = await window.showOpenFilePicker({
            types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
        });
        await loadFromHandle();
    } catch (err) {
        if (err?.name !== 'AbortError') {
            showStatus('ç»‘å®šæ–‡ä»¶å¤±è´¥ï¼š' + err.message, true);
        }
    }
}

async function loadFromHandle() {
    if (!metadataHandle) return;
    const file = await metadataHandle.getFile();
    const text = await file.text();
    const data = JSON.parse(text || '{}');
    applyMetadataMap(data);
    showStatus(`å·²ç»‘å®š ${file.name}ï¼Œåç»­ä¿å­˜å°†è‡ªåŠ¨è¦†ç›–`, false);
}

async function persistMetadata({ auto }) {
    const payload = JSON.stringify(metadataMap, null, 2);
    if (supportsFileSystemAccess && !metadataHandle) {
        metadataHandle = await promptForSaveHandle(auto);
    }

    if (metadataHandle && supportsFileSystemAccess) {
        const writable = await metadataHandle.createWritable();
        await writable.write(payload);
        await writable.close();
        showStatus('metadata.json å·²è‡ªåŠ¨è¦†ç›–ä¿å­˜', false);
    } else {
        triggerDownloadFallback(payload, auto);
    }
}

function showStatus(message, isError) {
    statusEl.textContent = message;
    statusEl.classList.toggle('error', !!isError);
    statusEl.classList.toggle('success', !isError);
}

function triggerDownloadFallback(payload, auto) {
    const blob = new Blob([payload], { type: 'application/json' });
    const filename = auto ? `metadata_auto_${Date.now()}.json` : 'metadata.json';
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
    showStatus('æµè§ˆå™¨é™åˆ¶ï¼Œå·²è§¦å‘ metadata.json ä¸‹è½½ï¼Œè¯·æ‰‹åŠ¨æ›¿æ¢æˆ–ä½¿ç”¨â€œç»‘å®š/é€‰æ‹©ä¿å­˜æ–‡ä»¶â€', true);
}

async function promptForSaveHandle(auto) {
    if (!supportsFileSystemAccess) return null;
    try {
        const handle = await window.showSaveFilePicker({
            suggestedName: 'metadata.json',
            types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
        });
        showStatus(`å·²é€‰æ‹© ${handle.name || 'metadata.json'}ï¼Œåç»­ä¿å­˜å°†è‡ªåŠ¨è¦†ç›–`, false);
        return handle;
    } catch (err) {
        if (err?.name !== 'AbortError') {
            showStatus('æœªè·å¾—æ–‡ä»¶å†™å…¥æƒé™ï¼Œå·²é€€å›ä¸‹è½½æ–¹å¼', true);
        } else if (!auto) {
            showStatus('å·²å–æ¶ˆé€‰æ‹©æ–‡ä»¶ï¼Œä¿å­˜ä¼šæ”¹ä¸ºä¸‹è½½', true);
        }
        return null;
    }
}

// åˆå§‹åŒ–
initApp();
</script>
</body>
</html>
